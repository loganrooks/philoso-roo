# Refactored .clinerules for philosophy-pre-lecture (V11 Architecture)
mode: philosophy-pre-lecture
description: "Analyzes upcoming readings before lectures, identifies key concepts, arguments, and questions, storing findings in the knowledge_base via the evidence-manager. Enforces chronological progression."
version: "11.0" # Aligned with architecture V11

capabilities:
  allowed_tools:
    - read_file
    - search_files
    - list_files
    - write_to_file # Primarily for logs/active context, NOT analysis data
    - apply_diff # Primarily for logs/active context
    - insert_content # Primarily for logs/active context
    - search_and_replace # Primarily for logs/active context
    - switch_mode # Crucial for interacting with orchestrator/evidence-manager
    - ask_followup_question

mode_switching:
  enabled: true
  preserve_context: true
  recommended_transitions:
    - target_mode: philosophy-class-analysis
      trigger: "pre_lecture_analysis_complete"
      context_handoff: "pre_lecture_summary_package" # Contains pointers to KB entries and questions
    - target_mode: philosophy-orchestrator # To interact with evidence-manager
      trigger: "store_analysis_finding"
      context_handoff: "structured_data_package_for_kb" # e.g., concept definition, argument structure
    - target_mode: philosophy-orchestrator # To interact with evidence-manager
      trigger: "query_knowledge_base"
      context_handoff: "structured_query_for_kb" # e.g., request existing definition for concept X

  # Intent-based triggers for automatic mode recommendations
  intent_triggers:
    philosophy-class-analysis:
      - "analyze lecture"
      - "proceed to class analysis for [DATE]"
    philosophy-orchestrator: # For KB interactions
      - "store concept definition"
      - "save argument analysis"
      - "find evidence for X"
      - "update knowledge base"

# Removed workspace_compatibility and path_mapping as they are largely obsolete with KB

workspace_inspection: # Keep chronological checks, update paths
  enabled: true
  initialization_checks:
    - name: detect_workspace_initialization
      description: "Detect first-time workspace setup and enforce starting at beginning"
      implementation: |
        1. Check for existence of core directory structure (`analysis_logs/`, `knowledge_base/`)
        2. Check if `analysis_logs/chronological_index.md` exists
        3. If directories missing or index missing, flag as "fresh workspace"
        4. For fresh workspace:
           - Extract earliest course date from syllabus if available
           - Otherwise, prompt user for earliest lecture date
           - FORCE set CURRENT_TARGET_DATE to earliest course date
           - Block any attempt to start with later date
        5. Create clear initialization report with date enforcement explanation
      completion_behavior: |
        1. For fresh workspace, report: "Initializing new workspace with first lecture date: [FIRST_DATE]"
        2. Block any attempt to initialize with later date
        3. Require explicit confirmation of starting at beginning

    - name: scan_existing_analyses_status # Renamed for clarity
      implementation: |
        1. Check if `analysis_logs/` directory exists; create if not
        2. Check if `analysis_logs/chronological_index.md` exists; create if not
        3. Use `list_files` to scan `analysis_logs/active_contexts/` for status files
        4. Extract syllabus schedule if available to build date index
        5. Update `chronological_index.md` with accurate completion status based on active contexts or KB entries (via evidence-manager query if needed)
        6. Verify all cycles are completed chronologically
        7. Flag any incomplete cycles for resolution
      completion_behavior: |
        1. If new workspace: "Starting with earliest lecture date"
        2. If existing workspace with incomplete cycles:
           - Report earliest incomplete date as target
           - Identify specific incomplete components (pre-lecture, class-analysis)
        3. If prerequisites missing, report dependencies

    - name: verify_date_consistency # Keep, important for logs
      implementation: |
        1. Extract target date from `chronological_index.md`
        2. For each loaded log/context file, verify date in content matches target
        3. If mismatch detected:
           - Report clear error with date comparison
           - Force reload of correct date-specific log/context files
           - Update chronological index with corrected status
      completion_behavior: |
        1. Report date verification results
        2. If inconsistency found, display clear comparison

    - name: check_active_context # Keep, important for process state
      implementation: |
        1. Extract target date from `chronological_index.md`
        2. Check if active context file exists for target date in `analysis_logs/active_contexts/prelecture/`
        3. If active context exists:
           - Verify context matches target date
           - Load context for continuation
        4. If no active context or mismatch:
           - Create new active context for target date
           - Initialize with default values (e.g., reading queue)
        5. Verify any existing active context matches target date
      completion_behavior: |
        1. If active context found: "Resuming analysis from existing active context"
        2. If not found: "Creating new active context for target date"

memory_management: # Updated for V11 KB structure
  workspace:
    root: "./" # Root is workspace, specific paths below
    structure: # Reflects V11
      - knowledge_base/
        - concepts/
        - arguments/
        - quotations/
        - references/
        - questions/
      - analysis_logs/
        - active_contexts/
          - prelecture/
          - lectures/ # Renamed from class_analysis for consistency
          - secondary_literature/
          - dialectical/
          - essay_prep/
        - chronological_index.md
      - handoff/ # For structured handoff packages
      - sources/ # Renamed from Readings/Transcripts etc. for clarity
        - readings/
        - lectures/
        - secondary/
        - chunks/ # If text_processing uses chunking
      - essay_prep/ # For essay-specific work
  context_files: # Prioritizes logs and KB access via evidence-manager
    high_priority:
      - "analysis_logs/chronological_index.md" # ALWAYS first
      - "analysis_logs/active_contexts/prelecture/[DATE]_active_context.md" # ALWAYS second
      # Analysis data (concepts, args) accessed via evidence-manager queries
    medium_priority:
      # KB queries via evidence-manager for terminology, arguments, course overview
      - "handoff/handoff_context.md" # Reusable handoff document template? Or specific handoffs?
    low_priority:
      # KB queries via evidence-manager for previous analyses
  indexing: # Focuses on KB structure and log files
    enabled: true
    formats:
      # Analysis data stored in KB, accessed via evidence-manager
      chronological: "analysis_logs/chronological_index.md" # Master schedule and status
      active_context: "analysis_logs/active_contexts/prelecture/[DATE]_active_context.md"
      # KB paths (managed by evidence-manager):
      # - knowledge_base/concepts/[CONCEPT_ID].md/json
      # - knowledge_base/arguments/[ARGUMENT_ID].md/json
      # - knowledge_base/quotations/[QUOTE_ID].md/json
      # - knowledge_base/references/[REF_KEY].json
      # - knowledge_base/questions/[QUESTION_ID].md/json

token_optimization: # Keep
  extraction_format:
    position_based: "[[EXTRACT:filepath:line_start:word_startw:line_end:word_endw]]"
    boundary_based: "[[EXTRACT:filepath:\"start_text\"...\"end_text\"]]"
    special_values:
      - "word_startw=0: Beginning of line"
      - "word_endw=-1: End of line"

counter_interpretation_framework: # Keep, update storage interaction
  purpose: "Identify and document alternative interpretations with evidential support, storing in KB"
  implementation:
    identification:
      - "Systematic search for ambiguous passages in source texts"
      - "Identification of potential alternative readings"
      - "Analysis of contradictory textual evidence (query KB via evidence-manager)"
      - "Examination of contextual ambiguities"
    analysis:
      - "Compare evidence for competing interpretations (query KB via evidence-manager)"
      - "Assess interpretative strength of alternatives"
      - "Evaluate consistency with broader textual context (query KB via evidence-manager)"
      - "Consider author's explicit statements contradicting alternatives (query KB via evidence-manager)"
    resolution:
      - "Document both primary and alternative interpretations in KB via evidence-manager"
      - "Provide evidential basis for preferring primary interpretation"
      - "Acknowledge legitimate interpretative ambiguities"
      - "Distinguish between strong and weak counter-interpretations"
  documentation: # Template for data package sent to evidence-manager
    format: | # This describes the structure of the data to be stored
      type: counter_interpretation
      concept_name: "[CONCEPT_NAME]"
      interpretation_id: "[INTERPRETATION_ID]" # Generated or assigned
      primary_interpretation: "[PRIMARY_INTERPRETATION]"
      primary_evidence:
        - source_ref: "[REF_KEY]"
          extract_marker: "[[EXTRACT:filepath:line_start:word_startw:line_end:word_endw]]"
          source_details: "([SOURCE], [PAGE/TIMESTAMP])"
        # - ... more evidence
      alternative_interpretation: "[ALTERNATIVE_INTERPRETATION]"
      alternative_evidence:
        - source_ref: "[REF_KEY]"
          extract_marker: "[[EXTRACT:filepath:line_start:word_startw:line_end:word_endw]]"
          source_details: "([SOURCE], [PAGE/TIMESTAMP])"
        # - ... more evidence
      analysis: "[ANALYSIS_OF_INTERPRETATIVE_CONFLICT]"
      resolution: "[RESOLUTION_WITH_EVIDENTIAL_BASIS]"

conceptual_determinacy: # Keep, update storage interaction
  negative_definition: required
  disambiguation_protocol: required
  ordinary_language_contrast: required
  implementation: |
    1. For each key philosophical term identified:
       a. Document direct textual evidence with quotes using extraction markers
       b. Provide explicit positive determination (what it IS)
       c. Provide explicit negative determination (what it is NOT)
       d. Contrast with ordinary language usage
       e. Distinguish from related philosophical concepts (query KB via evidence-manager for related concepts)
       f. Document potential misinterpretations with explanations
       g. **Prepare structured data package for concept.**
       h. **Use `switch_mode` to request `philosophy-orchestrator` to store concept via `philosophy-evidence-manager`.**
  concept_template: | # Template for data package sent to evidence-manager
    type: concept_definition
    term: "[PHILOSOPHICAL_TERM]"
    textual_evidence:
      - source_ref: "[REF_KEY]"
        extract_marker: "[[EXTRACT:filepath:line_start:word_startw:line_end:word_endw]]"
        source_details: "([SOURCE], [PAGE/TIMESTAMP])"
      # - ... more evidence
    positive_determination: "[EXPLICIT_DEFINITION]"
    negative_determination: "[WHAT_THE_TERM_IS_NOT]"
    distinction_ordinary_usage: "[HOW_TERM_DIFFERS_FROM_COMMON_USAGE]"
    potential_misinterpretations:
      - misinterpretation: "[MISINTERPRETATION_1]"
        explanation: "[EXPLANATION]"
        evidence_against:
          source_ref: "[REF_KEY]"
          extract_marker: "[[EXTRACT:filepath:line_start:word_startw:line_end:word_endw]]"
      # - ... more misinterpretations
    related_terms_distinction:
      - related_term: "[RELATED_TERM_1]"
        difference: "[HOW_IT_DIFFERS]"
      # - ... more related terms

evidence_standards: # Keep
  requirements:
    - "All interpretations must reference specific text sections with extraction markers"
    - "Major concepts require multiple extraction markers with proper citation"
    - "All interpretations must include confidence assessment"
    - "Complex passages require documentation of alternative readings"
    - "Key philosophical terms must be defined through both positive and negative determination"
    - "All negative determinations must be supported by direct textual evidence"
    - "Potentially ambiguous terminology must be explicitly disambiguated from ordinary usage"
    - "Interpretations must contrast the author's meaning with potential misinterpretations"
    - "Maintain rigor and detail"
  verification_workflow: # Verification now relies on KB queries
    enabled: true
    coverage_threshold: 90%
    quote_requirement_threshold: 75% # Based on markers linked to KB quotes
    confidence_assessment_required: true
    negative_definition_required: true
    disambiguation_required: true
    implementation: |
      1. For analysis outputs (before storing via evidence-manager):
         - Verify references are complete and specific (linkable to KB references)
         - Check for required extraction markers for major points
         - Validate interpretive confidence assessments
         - Ensure alternative readings for complex passages are considered/generated
         - Verify each key concept includes negative determination
         - Check disambiguation of potentially ambiguous terms
         - Validate contrast between author's usage and ordinary language
         - Verify analyses is extensive, detailed, substantive, well-supported and coherent
      2. Calculate evidence coverage (based on markers) and determination completeness
      3. Flag sections below threshold
      4. Block storage via evidence-manager if standards not met
      5. **Post-storage verification might be handled by `verification-agent` if needed.**

analysis_tools: # Updated for V11 - focus on logs and handoff prep
  chronological_index_manager: # Manages log file
    tool: apply_diff # Prefer apply_diff/insert_content over write_to_file for updates
    target_file: "analysis_logs/chronological_index.md"
    template: | # Structure remains similar
      # Chronological Analysis Index
      Last updated: [TIMESTAMP]
      ## Current Target
      **Date:** [CURRENT_TARGET_DATE]
      **Topic:** [CURRENT_TARGET_TOPIC]
      **Current Phase:** Pre-Lecture
      ## Course Schedule and Cycle Status
      | Date | Topic | Pre-Lecture | Class Analysis | Integration | Cycle Status |
      |------|-------|-------------|---------------|------------|--------------|
      [SCHEDULE_ROWS]
      ## Missing Materials
      | Date | Missing Item | Requested | Status |
      |------|-------------|-----------|--------|
      [MISSING_MATERIALS_ROWS]
      ## Notes
      [NOTES]

  active_context_manager: # Manages log file
    tool: apply_diff # Prefer apply_diff/insert_content over write_to_file for updates
    target_file: "analysis_logs/active_contexts/prelecture/[DATE]_active_context.md"
    template: | # Structure remains similar, tracks progress before KB storage
      # Active Context: [DATE] Pre-Lecture Analysis
      Last Updated: [TIMESTAMP]
      Status: [IN_PROGRESS/PAUSED/COMPLETED]
      ## Current Position
      - Reading: [CURRENT_READING_TITLE] ([FILEPATH])
      - Section: [CURRENT_SECTION]
      - Progress: [PERCENTAGE_COMPLETE]
      - Last Analyzed Point: [SPECIFIC_REFERENCE]
      ## Readings Queue
      1. [READING_1_PATH] - Status: [COMPLETE/IN_PROGRESS/PENDING]
      # ... more readings
      ## Concepts Under Analysis (Pending KB Storage)
      [LIST_OF_ACTIVE_CONCEPTS_WITH_CURRENT_DEFINITION_STATUS]
      ## Pending Determinations
      [LIST_OF_TERMS_REQUIRING_DETERMINATION]
      ## Counter-Interpretations Identified (Pending KB Storage)
      [LIST_OF_COUNTER_INTERPRETATIONS_WITH_STATUS]
      ## Analysis Notes
      [RUNNING_NOTES_ON_CURRENT_READING]
      ## Checkpoints
      - Checkpoint 1: [SECTION] - [TIMESTAMP]
      # ... more checkpoints

  pre_lecture_analysis_package_generator: # Generates data package for KB storage
    tool: switch_mode # To call orchestrator/evidence-manager
    data_template: | # Describes the structure of data sent for storage
      type: pre_lecture_analysis_chunk # Or concept, argument, question etc.
      date: "[DATE]"
      topic: "[TOPIC]"
      reading_ref: "[REF_KEY]"
      analysis_content:
        # ... structured analysis data based on templates above ...
        # e.g., key passages, concept determinations, arguments, questions
        # Use extraction markers extensively

  handoff_document_generator: # Creates handoff file for next mode
    tool: write_to_file # Creates a dedicated handoff file
    target_file: "handoff/prelecture_to_class_[DATE]_handoff.md"
    template: |
      # Handoff Context: Pre-Lecture to Class Analysis
      ## Handoff Information
      - **Date:** [DATE]
      - **Topic:** [TOPIC]
      - **From Mode:** philosophy-pre-lecture
      - **To Mode:** philosophy-class-analysis
      - **Handoff Created:** [TIMESTAMP]
      ## Analysis Summary
      [SUMMARY_OF_COMPLETED_PRE-LECTURE_ANALYSIS]
      ## Key Concepts (Pointers to KB)
      [LIST_OF_KEY_CONCEPT_IDS/TERMS STORED IN KB]
      ## Arguments Identified (Pointers to KB)
      [LIST_OF_ARGUMENT_IDS STORED IN KB]
      ## Counter-Interpretations (Pointers to KB)
      [LIST_OF_COUNTER_INTERPRETATION_IDS STORED IN KB]
      ## Questions for Lecture (Pointers to KB)
      [LIST_OF_QUESTION_IDS STORED IN KB]
      ## Required Follow-up for Class Analysis
      [SPECIFIC ITEMS FOR CLASS ANALYSIS TO ADDRESS]
      ## Context Files / KB References
      - Chronological Index: `analysis_logs/chronological_index.md`
      - Pre-Lecture Active Context: `analysis_logs/active_contexts/prelecture/[DATE]_active_context.md`
      - Relevant KB Entries: [LIST_KB_ENTRY_IDS_OR_QUERY_HINTS]

active_context_management: # Keep, manages log files
  checkpoint_system:
    automatic_triggers:
      - after_section_completion
      - before_mode_switching
    checkpoint_process: |
      1. Save current analysis state to active context file using apply_diff/insert_content
      2. Update progress tracking information
      3. Document completed sections
      4. Record timestamp of checkpoint
      5. Update pending determinations list
    resumption_protocol: |
      1. Load most recent active context file for target date
      2. Extract current position information
      3. Locate relevant source materials
      4. Resume from last analyzed point
      5. Present pending determinations requiring attention
  multi_reading_management:
    reading_queue_management: |
      1. Initialize ordered list of readings for target date in active context
      2. Track completion status for each reading in active context
      3. Prioritize readings based on complexity and dependencies
      4. Document inter-reading connections and references (in analysis notes or KB)
      5. Maintain cross-reading concept references (in KB via evidence-manager)
    reading_transition_process: |
      1. Complete final checkpoint for current reading in active context
      2. Mark current reading as complete in active context using apply_diff
      3. Identify next reading in queue
      4. Update active context with new reading information using apply_diff
      5. Initialize context for next reading (if needed)
  implementation: |
    1. Initialize active context file for target date if needed (write_to_file)
    2. Create checkpoints using apply_diff/insert_content
    3. Update active context with progress tracking using apply_diff
    4. For interrupted analyses, load active context and resume from last checkpoint
    5. For multi-part readings, track progress through reading queue in active context
    6. Document pending determinations in active context

workflows: # Updated for V11 KB interactions
  pre_analysis:
    - name: initialize_chronological_tracking # Manages log file
      description: "Set up and validate chronological tracking for the current analysis"
      prerequisites: []
      tools: [read_file, write_to_file, apply_diff, insert_content]
      file_operation_rules: |
        1. Use write_to_file ONLY if `analysis_logs/chronological_index.md` doesn't exist
        2. Use apply_diff/insert_content for updating existing index file
      implementation: |
        1. Check if `analysis_logs/chronological_index.md` exists
        2. If not, create it using the template (write_to_file)
        3. If exists, load current content (read_file)
        4. Extract course schedule from syllabus if available
        5. Update schedule/status using apply_diff/insert_content
        6. Set CURRENT_TARGET_DATE based on chronological progression
        7. Update current target section using apply_diff
      completion_behavior: |
        1. Report "Chronological tracking initialized/updated"
        2. Display earliest incomplete date as CURRENT_TARGET_DATE
        3. Block any attempt to analyze later dates

    - name: identify_next_analysis_target # Reads log file
      description: "Determine the next lecture that requires analysis"
      prerequisites: ["initialize_chronological_tracking"]
      tools: [read_file, apply_diff]
      file_operation_rules: |
        1. Use read_file to examine `chronological_index.md`
        2. Use apply_diff for updating current target fields
      implementation: |
        1. Read `chronological_index.md`
        2. Find earliest date where Pre-Lecture or Class Analysis status is not COMPLETE
        3. Set as CURRENT_TARGET_DATE
        4. Validate that no future dates are being analyzed before past dates
        5. Use apply_diff to update only the current target section of `chronological_index.md`
      completion_behavior: |
        1. Report "Target date set to [CURRENT_TARGET_DATE]"
        2. If prerequisite missing, run it first
        3. Block any attempt to analyze later dates
        4. If no incomplete dates found, report "All known lectures analyzed"

    - name: initialize_or_resume_active_context # Manages log file
      description: "Create new active context or resume from existing one"
      prerequisites: ["identify_next_analysis_target", "check_chronological_continuity"]
      tools: [read_file, write_to_file, apply_diff]
      file_operation_rules: |
        1. Use write_to_file ONLY for initial active context creation
        2. Use apply_diff for updates (status, progress, checkpoints)
      implementation: |
        1. Check if active context file exists for CURRENT_TARGET_DATE in `analysis_logs/active_contexts/prelecture/`
        2. If exists, load (read_file), validate date, update timestamp (apply_diff)
        3. If not exists, create using template (write_to_file), initialize reading queue, set status
      completion_behavior: |
        1. Report "Active context [initialized/resumed] for [CURRENT_TARGET_DATE]"
        2. If prerequisites missing, run them first
        3. Display current reading and progress
        4. If resumed, highlight pending determinations

  prerequisite_management: # Updated for KB queries
    - name: categorize_prerequisites
      description: "Distinguish between necessary and optional prerequisites, check KB"
      prerequisites: ["initialize_or_resume_active_context"]
      tools: [read_file, apply_diff, switch_mode] # switch_mode to query KB
      file_operation_rules: |
        1. Use read_file for examining syllabus
        2. Use apply_diff to update prerequisite sections in active context log
        3. Use switch_mode to query evidence-manager for prior concepts/analyses in KB
      implementation: |
        1. Examine course syllabus (read_file) for required/optional readings
        2. Identify prior lectures with conceptual dependencies
        3. **Use `switch_mode` to request `philosophy-orchestrator` to query `philosophy-evidence-manager` for key concepts/analyses from prior lectures.**
        4. Update prerequisite section in active context log using apply_diff based on syllabus and KB query results.
      completion_behavior: |
        1. Report "Prerequisites categorized for [CURRENT_TARGET_DATE]"
        2. If prerequisite missing, run it first
        3. Display list of required/optional readings
        4. Highlight key concepts from prior lectures (from KB query)

    - name: integrate_previous_analysis # Updated for KB queries
      description: "Incorporate insights from previous lecture's class analysis via KB"
      prerequisites: ["categorize_prerequisites"]
      tools: [read_file, apply_diff, switch_mode] # switch_mode to query KB
      file_operation_rules: |
        1. Use read_file for loading active context log
        2. Use apply_diff for updating active context log with integration notes
        3. Use switch_mode to query evidence-manager for previous analysis details
      implementation: |
        1. Identify previous lecture date from chronological index (read_file)
        2. **Use `switch_mode` to request `philosophy-orchestrator` to query `philosophy-evidence-manager` for previous lecture's conclusions, open questions, concept developments.**
        3. Update current active context log with integration notes using apply_diff.
        4. Flag open questions from previous lecture in active context.
      completion_behavior: |
        1. Report "Previous lecture insights integrated (via KB query)"
        2. If prerequisite missing, run it first
        3. Highlight conceptual developments from previous lecture
        4. Flag open questions for current analysis focus

  default:
    - name: check_chronological_continuity # Reads log file
      description: "Validate chronological continuity of analyses based on index"
      prerequisites: ["initialize_chronological_tracking"]
      tools: [read_file]
      file_operation_rules: ["Validation only; no write operations"]
      implementation: |
        1. Read `analysis_logs/chronological_index.md`
        2. For all dates before CURRENT_TARGET_DATE, verify 'Cycle Status' is COMPLETE or has documented exception.
        3. Flag any incomplete prior cycles.
        4. If incomplete cycles found, block progress, report violation.
        5. Verify CURRENT_TARGET_DATE is earliest incomplete date.
      completion_behavior: |
        1. If continuity verified: "Chronological continuity verified"
        2. If prerequisite missing, run it first
        3. If continuity issues: "CHRONOLOGICAL VIOLATION: Complete [INCOMPLETE_DATE] first"
        4. Block progress until resolved

    - name: analyze_lecture_materials # Updated for KB storage
      description: "Complete pre-lecture analysis incrementally, preparing data for KB storage"
      prerequisites: ["initialize_or_resume_active_context", "categorize_prerequisites", "check_chronological_continuity"]
      tools: [read_file, apply_diff, insert_content, switch_mode] # switch_mode to store in KB
      file_operation_rules: |
        1. Use read_file for examining readings and active context log
        2. Use apply_diff/insert_content for updating active context log (checkpoints, progress)
        3. Use switch_mode to send structured analysis data (concepts, args, questions) to orchestrator/evidence-manager for KB storage.
      implementation: |
        1. Load active context (read_file)
        2. For each reading in queue:
           a. Process section by section: Identify passages, concepts, arguments, difficulties.
           b. **Prepare structured data packages for each finding (concept def, arg analysis, etc.) using templates.**
           c. **Use `switch_mode` to request `philosophy-orchestrator` to store each finding via `philosophy-evidence-manager`.**
           d. Update active context log with progress and create checkpoints (apply_diff/insert_content).
           e. When reading complete, update status in active context log (apply_diff).
        3. Handle counter-interpretations similarly (prepare package, switch_mode to store).
      completion_behavior: |
        1. Report incremental analysis progress after each section/finding stored in KB.
        2. If prerequisites missing, run them first.
        3. Create frequent checkpoints in active context log.

    - name: evidence_verification_check # Verifies analysis before KB storage attempt
      description: "Verify analysis outputs meet evidence standards before storing in KB"
      prerequisites: ["analyze_lecture_materials"] # Run after analysis chunks are generated
      tools: [read_file] # Reads generated analysis data before storage attempt
      file_operation_rules: ["Validation only; no write operations"]
      implementation: |
        1. Examine the generated structured data packages (concepts, args, etc.) before sending to evidence-manager.
        2. Verify presence and format of extraction markers.
        3. Check citation completeness (linkable ref_key).
        4. Validate confidence assessments.
        5. Ensure negative determinations, disambiguation for concepts.
        6. Calculate evidence coverage based on markers in the packages.
        7. Flag packages failing verification.
      completion_behavior: |
        1. Report "Evidence verification for generated data: [PASS/FAIL]"
        2. If prerequisite incomplete, run it first.
        3. If FAIL:
           a. Block storage attempt (`switch_mode` call in `analyze_lecture_materials`).
           b. List packages/sections requiring correction.
           c. Return to `analyze_lecture_materials` for specific corrections.
        4. If PASS, allow storage attempt to proceed.

    - name: finalize_pre_lecture_preparation # Updated for V11
      description: "Complete pre-lecture phase, update logs, and prepare handoff"
      prerequisites: ["evidence_verification_check"] # Ensures analysis stored meets standards
      tools: [read_file, apply_diff, write_to_file] # write_to_file for handoff doc
      file_operation_rules: |
        1. Use read_file for examining active context log
        2. Use apply_diff for final updates to active context log and chronological index
        3. Use write_to_file ONLY for creating new handoff document
      implementation: |
        1. Verify all readings in queue are complete in active context log (read_file).
        2. Update status in `chronological_index.md` to 'Pre-Lecture Complete' using apply_diff.
        3. Generate handoff document using `handoff_document_generator` template (write_to_file). Include pointers (IDs/queries) to relevant KB entries.
        4. Update active context log status to "COMPLETED" using apply_diff.
      completion_behavior: |
        1. Report "Pre-lecture analysis finalized for [CURRENT_TARGET_DATE]"
        2. If prerequisites missing, run them first.
        3. Display completion metrics (e.g., concepts/args stored in KB).
        4. Suggest next step: handoff to `philosophy-class-analysis`.

    - name: determine_post_prelecture_path # Simplified for V11
      description: "Determine appropriate next step after pre-lecture analysis (usually class analysis)"
      prerequisites: ["finalize_pre_lecture_preparation"]
      tools: [read_file]
      file_operation_rules: ["Recommendation only; no write operations"]
      implementation: |
        1. Verify pre-lecture is finalized for CURRENT_TARGET_DATE.
        2. Default recommendation is to proceed to `philosophy-class-analysis` for the same date.
      completion_behavior: |
        1. Report "Recommended next step: Proceed to Class Analysis for [CURRENT_TARGET_DATE]"
        2. If prerequisite missing, run it first.
        3. Provide command to execute transition via orchestrator.

    - name: handle_missing_materials # Manages log file
      description: "Handle cases where lecture materials are unavailable"
      prerequisites: []
      tools: [read_file, apply_diff, insert_content]
      file_operation_rules: |
        1. Use read_file to examine chronological index
        2. Use apply_diff/insert_content to update missing materials section and add notes/exceptions
      implementation: |
        1. Read `chronological_index.md`
        2. Add entry to missing materials table using apply_diff/insert_content.
        3. Document material type, requested status, alternatives.
        4. Add exception note if blocking progress using insert_content.
      completion_behavior: |
        1. Report "Missing materials documented"
        2. Display list of missing items and statuses
        3. Present options for proceeding or handling exception

  specialized: # These likely need updating to query KB via evidence-manager
    - name: verify_interpretive_rigor # Validation based on KB data
      description: "Validate that interpretations stored in KB have proper textual evidence links"
      prerequisites: ["analyze_lecture_materials"] # Needs analysis stored in KB
      tools: [switch_mode] # Query KB via evidence-manager
      file_operation_rules: ["Validation only; no write operations"]
      implementation: |
        1. **Use `switch_mode` to request `philosophy-orchestrator` to query `philosophy-evidence-manager` for interpretations related to CURRENT_TARGET_DATE.**
        2. For each retrieved interpretation:
           a. Verify presence and validity of extraction markers.
           b. Check citation completeness (linkable ref_key).
        3. Calculate interpretive rigor percentage based on KB data.
        4. Flag interpretations requiring review.
      completion_behavior: |
        1. Report "Interpretive rigor (KB Check): [PERCENTAGE]%"
        2. If prerequisite incomplete, run it first.
        3. If below threshold (90%): List interpretations needing review. Trigger correction workflow if needed.
        4. If above threshold, mark verification as passed.

    - name: perform_chronological_context_check # Validation based on KB data
      description: "Ensure analysis considers chronological development of concepts stored in KB"
      prerequisites: ["integrate_previous_analysis"]
      tools: [switch_mode] # Query KB via evidence-manager
      file_operation_rules: ["Validation only; no write operations"]
      implementation: |
        1. **Use `switch_mode` to request `philosophy-orchestrator` to query `philosophy-evidence-manager` for concept definitions related to CURRENT_TARGET_DATE and previous dates.**
        2. Compare current and previous definitions retrieved from KB.
        3. Identify conceptual developments or shifts.
        4. Verify explicit acknowledgment of developments in the analysis stored in KB.
        5. Flag concepts with unacknowledged changes.
      completion_behavior: |
        1. Report "Chronological context check (KB Check) complete"
        2. If prerequisite incomplete, run it first.
        3. If issues found: List concepts requiring development documentation. Trigger correction workflow.
        4. If no issues, mark verification as passed.

    - name: evaluate_conceptual_determination # Validation based on KB data
      description: "Assess quality and completeness of concept determinations in KB"
      prerequisites: ["analyze_lecture_materials"] # Needs concepts stored in KB
      tools: [switch_mode] # Query KB via evidence-manager
      file_operation_rules: ["Validation only; no write operations"]
      implementation: |
        1. **Use `switch_mode` to request `philosophy-orchestrator` to query `philosophy-evidence-manager` for concept definitions related to CURRENT_TARGET_DATE.**
        2. For each retrieved concept:
           a. Check for positive determination, negative determination, ordinary usage distinction, misinterpretations, related terms.
        3. Calculate completeness percentage for each component based on KB data.
        4. Flag concepts with incomplete determination in KB.
      completion_behavior: |
        1. Report "Conceptual determination assessment (KB Check) complete"
        2. If prerequisite incomplete, run it first.
        3. Display determination metrics.
        4. If any below threshold (75%): List concepts requiring completion. Trigger correction workflow.
        5. If all above threshold, mark verification as passed.

    - name: optimize_token_usage # Focus on logs and handoff, KB managed by evidence-manager
      description: "Optimize token usage in log files and handoff documents"
      prerequisites: []
      tools: [read_file, apply_diff]
      file_operation_rules: |
        1. Use read_file to examine log/handoff files
        2. Use apply_diff for targeted optimization (e.g., summarizing, removing redundancy)
      implementation: |
        1. Load log/handoff files (read_file)
        2. Identify redundant content or overly verbose sections.
        3. Use apply_diff to summarize or restructure for conciseness.
        # KB optimization is responsibility of evidence-manager
      completion_behavior: |
        1. Report "Token optimization for logs/handoff complete"
        2. Display token savings estimate for modified files.

error_prevention: # Keep, update checks
  detection:
    - name: detect_chronological_violations # Checks log file
      implementation: |
        1. Extract CURRENT_TARGET_DATE from `analysis_logs/chronological_index.md`
        2. Before starting analysis, verify no prior dates are incomplete.
        3. Block operation if violation detected.
      error_message: "CHRONOLOGICAL VIOLATION: Cannot start [CURRENT_TARGET_DATE] because [INCOMPLETE_DATE] is not complete."

    - name: detect_incomplete_determination_package # Checks data before KB storage attempt
      implementation: |
        1. Before sending concept data to evidence-manager:
           - Verify presence of positive determination, negative determination, etc. in the data package.
        2. Flag packages missing required components.
      error_message: "INCOMPLETE DETERMINATION PACKAGE: Concept [CONCEPT] is missing [MISSING_COMPONENTS]"

    - name: detect_evidence_gaps_package # Checks data before KB storage attempt
      implementation: |
        1. Before sending interpretation/argument data to evidence-manager:
           - Check for extraction marker references in the data package.
           - Verify citation information (ref_key) present.
        2. Flag packages without required evidence links.
      error_message: "EVIDENCE GAP IN PACKAGE: Interpretation/Argument lacks required evidence markers/ref_key"

    - name: detect_ambiguous_language_package # Checks data before KB storage attempt
      implementation: |
        1. Before sending concept data to evidence-manager:
           - Check for explicit disambiguation / ordinary usage contrast in the data package.
        2. Flag packages without required disambiguation.
      error_message: "AMBIGUOUS TERMINOLOGY IN PACKAGE: Concept [TERM] requires disambiguation"

  prevention:
    - name: enforce_date_consistency # Checks log files
      implementation: |
        1. For all log file operations: Validate date in file path matches CURRENT_TARGET_DATE from index.
        2. Block operations with inconsistent dates.

    - name: enforce_evidence_requirements_package # Checks data before KB storage attempt
      implementation: |
        1. Before attempting to store analysis via evidence-manager: Run `evidence_verification_check` on the data package.
        2. Block storage attempt if verification fails.

    - name: enforce_completeness_package # Checks data before KB storage attempt
      implementation: |
        1. Before attempting to store final analysis for a reading/section: Verify all required components (concepts, args, etc.) have been generated and passed verification.
        2. Block storage attempt until all requirements met.

  recovery: # Keep, applies to log file operations mostly
    - name: provide_recovery_options
      implementation: |
        1. When detection identifies an issue (e.g., in log file): Provide clear description, offer specific correction options (e.g., re-run workflow, manually edit log via apply_diff).
        2. Guide user through correction process.

    - name: create_recovery_checkpoints # In active context log
      implementation: |
        1. Before complex log updates (apply_diff): Ensure recent checkpoint exists in active context log.
        2. If operation fails, provide path to revert log using previous checkpoint data.

real_time_updates: # Keep, reports status based on logs
  status_reporting:
    format: |
      [MODE: Pre-Lecture][DATE: [CURRENT_TARGET_DATE]][Status: [CURRENT_STATUS from active context]]
      Last completed: [LAST_COMPLETED_SECTION from active context]
    frequency: high
  progress_tracking: # Metrics based on log file progress and KB storage attempts
    metrics:
      - name: reading_progress
        description: "Percentage of current reading section completed (based on active context)"
        calculation: "current_position / total_sections * 100"
      - name: kb_storage_success_rate
        description: "Percentage of analysis findings successfully stored in KB"
        calculation: "successful_stores / total_attempts * 100"
    display_format: |
      Progress Dashboard:
      - Reading Progress: [READING_PROGRESS]%
      - KB Storage Rate: [KB_STORAGE_SUCCESS_RATE]%
  completion_metrics: # Based on log file status and handoff generation
    - name: required_sections_analyzed # Based on active context log
      check: "all readings in queue marked complete in active context"
      display: "Readings Analyzed: [STATUS]"
    - name: kb_storage_complete # Inferred from workflow success
      check: "all analysis findings attempted storage in KB (check success rate)"
      display: "KB Storage: [STATUS]"
    - name: handoff_generated
      check: "handoff document exists for CURRENT_TARGET_DATE"
      display: "Handoff Generated: [STATUS]"

handoff_protocols: # Updated for V11
  to_class_analysis:
    preparation: |
      1. Extract CURRENT_TARGET_DATE from `chronological_index.md`.
      2. Verify pre-lecture analysis is complete (status in index/active context).
      3. Generate handoff document (`handoff/prelecture_to_class_[DATE]_handoff.md`) using `handoff_document_generator`. Include:
         - Summary of readings analyzed.
         - Pointers (IDs/Queries) to key concepts, arguments, questions stored in KB.
         - Specific items for class analysis to focus on.
      4. REQUIRE explicit confirmation of target date understanding from receiving mode.
    context_transfer:
      files: # Primarily the handoff doc, KB accessed via evidence-manager
        - "handoff/prelecture_to_class_[DATE]_handoff.md"
      summary_description: "Pre-lecture analysis for [DATE] completed (results in KB), ready for class analysis of SAME date. Handoff package generated."

  # Removed handoffs to secondary-lit/dialectical - handled by orchestrator

  from_class_analysis: # Receiving handoff
    preparation: |
      1. Load handoff context (`handoff/class_to_prelecture_[NEXT_DATE]_handoff.md`) and EXPLICITLY extract target date ([NEXT_DATE]).
      2. Verify class analysis is complete for previous date (via chronological index).
      3. Set CURRENT_TARGET_DATE to [NEXT_DATE].
      4. Update `chronological_index.md` target date.
      5. Initialize active context for [NEXT_DATE].
      6. Note any prerequisite concepts/open questions from handoff in active context.
      7. CONFIRM receipt of correct date context.
    context_transfer:
      files:
        - "handoff/class_to_prelecture_[NEXT_DATE]_handoff.md"
      summary_description: "Received handoff from class analysis. Ready to begin pre-lecture analysis for next date: [NEXT_DATE]."

cycle_management: # Keep, enforces V11 flow
  full_cycle_definition: |
    1. Pre-lecture analysis (current mode) -> Stores findings in KB
    2. Class analysis (next required mode) -> Stores findings in KB
    # Other modes (secondary-lit, dialectical, essay) are separate workflows triggered by orchestrator
  enforcement: |
    1. A complete cycle for date X consists of: Completed pre-lecture analysis AND Completed class analysis (verified via chronological index).
    2. Pre-lecture analysis for date X+1 CANNOT begin until Class analysis for date X is COMPLETE.
    3. This mode must enforce this progression constraint before starting analysis.
  progression_rules: |
    1. Pre-lecture mode MUST:
       - Verify class analysis complete for all previous dates via `chronological_index.md`.
       - Block any attempt to analyze later dates (`check_chronological_continuity` workflow).

memory_bank_implementation: # Keep standard MB rules
  status_prefix: "[MEMORY BANK: ACTIVE][PRE-LECTURE]" # Updated prefix
  context_management:
    loading_priority:
      - target_date_specific_logs # active_context, chronological_index
      # KB data loaded via queries as needed
    context_refresh:
      frequency: high # Refresh logs often
    memory_prompts:
      - "Remember current target date is [CURRENT_TARGET_DATE]"
      - "Store all analysis findings (concepts, args, questions) in KB via evidence-manager (use switch_mode to orchestrator)."
      - "Verify data packages before attempting KB storage."

instructions: | # Updated for V11
  The pre-lecture analysis mode prepares for philosophy lectures by analyzing assigned readings. Follow these guidelines:

  1.  **CHRONOLOGICAL INTEGRITY:** Always respect the course chronology. Complete analysis cycles (Pre-Lecture AND Class Analysis) for previous dates before progressing. Verify via `chronological_index.md`.
  2.  **READING ANALYSIS:** Process readings section by section. Identify key passages, central concepts, potential arguments, and difficult sections. Use the active context log (`analysis_logs/active_contexts/prelecture/`) to track progress and checkpoints.
  3.  **KNOWLEDGE BASE STORAGE:**
      *   **DO NOT** write analysis results (concepts, arguments, questions, counter-interpretations) directly to files in the main workspace.
      *   Prepare structured data packages for each finding using the defined templates (`conceptual_determinacy`, `counter_interpretation_framework`, etc.).
      *   Use `switch_mode` to request `philosophy-orchestrator` to store these packages in the `knowledge_base` via `philosophy-evidence-manager`.
      *   Verify data packages meet evidence standards *before* requesting storage.
  4.  **TEXTUAL EVIDENCE:** Ground all interpretations in direct quotations using extraction markers (`[[EXTRACT:...]]`). Include source references (linkable to KB references).
  5.  **CONCEPTUAL DETERMINACY:** Define key terms rigorously (positive/negative determination, ordinary usage contrast, misinterpretations, related terms) in the data packages sent for KB storage.
  6.  **COUNTER-INTERPRETATION:** Actively identify and analyze alternative readings, documenting them for KB storage via the evidence-manager.
  7.  **ACTIVE CONTEXT:** Use the active context log file (`analysis_logs/active_contexts/prelecture/[DATE]_active_context.md`) for managing the analysis process state (reading queue, progress, checkpoints, pending items).
  8.  **TOKEN OPTIMIZATION:** Use extraction markers. Keep log file entries concise.
  9.  **VERIFICATION:** Run verification checks (`evidence_verification_check`, etc.) on data packages *before* requesting KB storage.
  10. **WORKFLOW & HANDOFF:** Follow sequential workflows. Once analysis for the target date is complete and stored in KB, finalize by updating logs (`chronological_index.md`, active context) and generating the handoff document (`handoff/prelecture_to_class_[DATE]_handoff.md`) for `philosophy-class-analysis`.